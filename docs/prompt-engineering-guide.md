# 复杂任务 Prompt 编写指南

> 💡 **核心理念**：Prompt Engineering 已经进化为 **Context Engineering** —— 你在设计的是一个动态的信息系统，不只是一句话。

---

## 一、Prompt 的核心元素

一个完整的 Prompt 通常包含以下四个核心元素（根据任务需要组合使用）：

| 元素 | 说明 | 示例 |
|------|------|------|
| **Instruction（指令）** | 你希望 AI 执行的具体任务 | "将以下文本翻译成西班牙语" |
| **Context（上下文）** | 引导 AI 生成更好响应的外部信息或额外背景 | 当前日期、用户身份、业务场景 |
| **Input Data（输入数据）** | 需要处理的输入内容或问题 | 用户提供的文本、代码、数据 |
| **Output Indicator（输出指示）** | 期望的输出类型或格式 | "以 JSON 格式输出"、"分三点总结" |

---

## 二、核心原则

### 2.1 明确角色定义

清晰地定义 AI 的角色，使其理解自身的职责和行为范围。

```
你是一位资深的代码审查专家，专注于 TypeScript 和 React 项目。
你的职责是发现代码中的潜在问题、性能隐患和可维护性问题。
```

### 2.2 提供详细的背景信息

为 AI 提供足够的上下文，包括任务的目的、目标受众和相关细节。这有助于 AI 更准确地理解任务要求，生成符合预期的响应。

### 2.3 上下文工程（Context Engineering）

> 🔥 **2024-2025 年最热门的概念！**

**上下文工程**是指设计和优化传递给 LLM 的**完整信息环境**，包括：

- **动态元素管理**：当前日期/时间、用户状态、会话历史
- **分隔符使用**：用 `<user_query></user_query>` 等标签明确区分不同类型的信息
- **相关知识检索（RAG）**：动态获取和注入相关背景知识
- **工具定义**：清晰描述可用工具及其使用方式
- **短期记忆**：管理会话状态和历史上下文
- **长期记忆**：从向量存储中检索相关知识

```
### 当前上下文 ###
- 当前日期时间：2024-12-10 17:40 UTC+8
- 用户角色：高级开发者
- 项目类型：企业级 React 应用

<user_query>
请分析这段代码的性能问题
</user_query>

<code_context>
// 用户提供的代码
</code_context>
```

### 2.4 清晰的任务描述（避免歧义）

提供清晰、具体的指令有助于模型理解任务，减少歧义。

| ❌ 不好的写法 | ✅ 好的写法 |
|--------------|------------|
| "请阅读这篇文章" | "请总结这篇文章的三个主要观点" |
| "帮我改进代码" | "请优化这段代码的时间复杂度，并解释改动原因" |
| "表单有什么变化？" | "列出表单中新增的三个字段名称" |

### 2.5 提供具体示例（Few-shot Learning）

通过提供示例，展示期望的输出格式和风格，有助于模型生成符合预期的结果：

```
### 任务：将用户反馈分类

### 示例：
输入："网站加载太慢了"
输出：{"category": "performance", "severity": "medium", "sentiment": "negative"}

输入："新功能非常好用！"  
输出：{"category": "feature", "severity": "low", "sentiment": "positive"}

### 现在处理：
输入："登录按钮点击没反应"
```

### 2.6 分步指导（分解复杂任务）

将复杂的任务拆分为简单的步骤，引导 AI 逐步完成。这种方法有助于提高响应的准确性和连贯性：

```
请按以下步骤分析这段代码：

1. **识别问题**：找出代码中的潜在 bug 或错误
2. **评估影响**：分析每个问题的严重程度和影响范围
3. **提供方案**：给出具体的修复建议和代码示例
4. **预防建议**：提出避免类似问题的最佳实践
```

### 2.7 思维链引导（Chain of Thought）

鼓励模型逐步推理，分解复杂问题，减少幻觉现象：

```
请分析这个算法的时间复杂度。

思考过程：
1. 首先，识别循环结构和递归调用
2. 然后，分析每层循环的迭代次数
3. 接着，计算嵌套循环的乘积
4. 最后，用大 O 表示法总结

让我们一步一步来...
```

### 2.8 约束条件明确

告知 AI 在何种情况下应避免回答，或提供"我不知道"的回应，以减少幻觉的发生：

```
### 约束条件：
- 只回答与 TypeScript 相关的问题
- 如果问题超出你的知识范围，请直接说"我不确定"
- 不要编造不存在的 API 或库
- 代码示例必须可以直接运行
```

### 2.9 结构化输出格式

明确指定输出的数据结构和格式要求（如 JSON、XML、表格等），使用标签或模式定义清晰地约束输出内容：

```
请以以下 JSON 格式输出分析结果：

{
  "issues": [
    {
      "line": number,
      "type": "bug" | "performance" | "style",
      "severity": "high" | "medium" | "low",
      "description": string,
      "suggestion": string
    }
  ],
  "summary": string,
  "overallScore": number  // 1-10
}
```

### 2.10 反思与验证机制

在 prompt 中嵌入自我检查环节，要求模型在输出前进行反思和验证：

```
### 输出前的检查清单：
在最终输出前，请验证：
1. [ ] 所有代码示例是否语法正确？
2. [ ] 是否回答了用户的核心问题？
3. [ ] 建议是否可操作且具体？
4. [ ] 是否有任何假设需要说明？

如有任何不确定的地方，请明确标注。
```

### 2.11 避免开放性问题

尽量使用封闭式、具体的提问方式，而非宽泛的开放性问题：

| ❌ 开放式（易产生幻觉） | ✅ 封闭式（更精准） |
|------------------------|-------------------|
| "这个框架怎么样？" | "列出 React 18 的三个主要新特性" |
| "代码有什么问题？" | "这段代码是否存在内存泄漏风险？" |
| "帮我优化一下" | "请将这个 O(n²) 算法优化到 O(n log n)" |

---

## 三、进阶实践原则

### 3.1 从简单开始，迭代优化

**迭代式开发**：不要试图一次写出完美的 prompt，而是：

1. 从简单的 prompt 开始
2. 测试并观察输出
3. 逐步添加更多上下文和约束
4. 持续迭代直到达到预期效果

```
版本 1：请分析这段代码
版本 2：请分析这段代码的性能问题
版本 3：请分析这段代码的性能问题，重点关注循环和内存使用
版本 4：（完整版本，包含格式要求、示例等）
```

### 3.2 正向指令优于负向指令

**说"做什么"而非"不做什么"**：

| ❌ 负向指令（容易失效） | ✅ 正向指令（更有效） |
|------------------------|---------------------|
| "不要问用户的个人偏好" | "从全球热门电影列表中推荐" |
| "不要使用专业术语" | "用初中生能理解的语言解释" |
| "不要输出太长的内容" | "用 2-3 句话简洁回答" |

### 3.3 分隔符与格式化

使用清晰的分隔符区分不同类型的信息：

```
### 系统指令 ###
你是一个代码审查助手。

### 用户代码 ###
```typescript
function add(a, b) { return a + b; }
```

### 输出格式 ###
请按以下结构输出审查结果：
...
```

### 3.4 信息密度与相关性

**黄金法则：宁精勿滥**

- ✅ 提供**相关且精炼**的上下文
- ❌ 避免塞入大量无关信息（会稀释关注点）
- ✅ 每条信息都应该服务于任务目标

### 3.5 "能否合理完成？"测试

在提交 prompt 前，问自己：

> "如果我是一个只能看到这些信息的人，我能合理地完成这个任务吗？"

如果答案是否定的，说明：
- 缺少必要的上下文
- 指令不够清晰
- 需要提供更多示例

### 3.6 模型参数调优意识

根据任务类型调整参数（如果平台支持）：

| 任务类型 | Temperature | 说明 |
|---------|-------------|------|
| 事实性回答、代码生成 | 0.0 - 0.3 | 需要准确性和一致性 |
| 创意写作、头脑风暴 | 0.7 - 1.0 | 需要多样性和创造性 |
| 平衡型任务 | 0.4 - 0.6 | 兼顾准确性和灵活性 |

### 3.7 工具与能力边界定义

当 AI 需要使用工具时，清晰定义：

```
### 可用工具 ###
1. search_web(query: string) - 搜索网络获取最新信息
2. read_file(path: string) - 读取指定路径的文件
3. execute_code(code: string) - 执行 Python 代码

### 工具使用规则 ###
- 只在确实需要外部信息时使用 search_web
- 执行代码前先解释你要做什么
- 如果工具返回错误，分析原因并重试
```

### 3.8 错误处理与回退策略

预设 AI 遇到困难时的行为：

```
### 错误处理指南 ###
- 如果无法理解用户意图，请礼貌地要求澄清
- 如果问题超出能力范围，诚实告知并建议替代方案
- 如果存在多种可能的解释，列出选项让用户选择
- 永远不要编造不确定的信息
```

### 3.9 记忆与状态管理

对于多轮对话或长期任务：

```
### 会话记忆 ###
上一轮讨论总结：用户正在重构一个 React 组件，已完成 Props 类型定义

### 当前状态 ###
- 已完成：类型定义、基础结构
- 进行中：事件处理逻辑
- 待完成：样式和测试

### 本轮任务 ###
继续帮助用户完成事件处理逻辑
```

### 3.10 评估与可追溯性

建立 prompt 效果的评估机制：

```
### 输出质量自评 ###
请在回答末尾附加：
- 置信度：高/中/低
- 信息来源：已知知识/推理/需要验证
- 潜在局限：（如有）
```

---

## 四、复杂任务 Prompt 模板

综合以上原则，这里是一个**复杂任务的 Prompt 模板**：

```markdown
# [任务名称]

## 角色定义
你是 [角色描述]，专注于 [领域]。
你的核心职责是 [具体职责]。

## 上下文信息
- 当前时间：[动态时间]
- 用户背景：[用户信息]
- 项目环境：[相关背景]

## 任务描述
[清晰、具体的任务说明]

## 输入数据
<input>
[用户提供的输入]
</input>

## 执行步骤
1. [步骤一]
2. [步骤二]
3. [步骤三]
...

## 示例（可选）
### 输入示例：
[示例输入]

### 期望输出：
[示例输出]

## 输出格式
[明确的输出格式要求，如 JSON Schema]

## 约束与边界
- [约束 1]
- [约束 2]
- [边界条件]

## 质量检查
完成前请验证：
1. [ ] [检查项 1]
2. [ ] [检查项 2]
3. [ ] [检查项 3]
```

---

## 五、常见陷阱与解决方案

| 陷阱 | 问题描述 | 解决方案 |
|------|---------|---------|
| **信息过载** | 塞入太多无关上下文 | 只保留与任务直接相关的信息 |
| **指令模糊** | 用"差不多"、"合适的"等模糊词 | 使用具体的数字、格式、标准 |
| **负向指令** | 过多使用"不要"而非"要" | 改写为正向的期望行为 |
| **格式自由** | 不指定输出格式导致不一致 | 提供明确的格式模板或 Schema |
| **缺乏示例** | 期望 AI 猜测你想要的格式 | 提供 1-3 个具体的示例 |
| **忽略边界** | 没有定义失败时的行为 | 明确约束条件和回退策略 |

---

## 六、心法总结

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Prompt Engineering 心法                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   🎯 核心公式：                                                      │
│      好的输出 = 清晰的角色 + 充分的上下文 + 具体的指令 + 明确的格式 │
│                                                                      │
│   🔄 迭代法则：                                                      │
│      1. 先跑起来，再优化                                            │
│      2. 观察失败模式，针对性修复                                    │
│      3. 建立评估标准，量化改进                                      │
│                                                                      │
│   💡 黄金问题：                                                      │
│      "给定这些信息，AI 能否合理地完成任务？"                        │
│                                                                      │
│   🚫 记住：AI 不是读心者                                            │
│      - 你不说的，它不会知道                                         │
│      - 你说得模糊，它就猜测                                         │
│      - 你给的示例，就是它的标准                                     │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 七、整体原则总结

### Prompt 工程的演进脉络

和 Web 技术一样，Prompt 工程也在不断演进。理解这个演进过程，能帮你更好地掌握核心原则：

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Prompt 工程的三个阶段                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   Phase 1: 盲目提问（Blind Prompting）                              │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  "帮我写个代码"  "优化一下这个"  "解释一下"                │   │
│   │                       │                                      │   │
│   │                       └── 模糊、随意、靠运气                 │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                              ▼                                       │
│   Phase 2: Prompt Engineering（提示工程）                           │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  结构化 Prompt + 示例 + 约束 + 格式                         │   │
│   │                       │                                      │   │
│   │                       └── 静态模板，一次性设计               │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                              ▼                                       │
│   Phase 3: Context Engineering（上下文工程）🔥 当前趋势             │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  动态上下文 + RAG + 记忆管理 + 工具调用 + 状态追踪          │   │
│   │                       │                                      │   │
│   │                       └── 设计完整的信息系统                 │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│   核心洞察：从"写一句好的 Prompt"到"设计一套动态信息系统"         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 为什么这些原则有效？

```
┌─────────────────────────────────────────────────────────────────────┐
│                    理解 LLM 的本质                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   LLM 不是：                          LLM 是：                      │
│   ┌────────────────────┐              ┌────────────────────┐        │
│   │  ❌ 读心者          │              │  ✅ 模式匹配器      │        │
│   │  ❌ 全知全能        │              │  ✅ 上下文延续者    │        │
│   │  ❌ 逻辑推理机      │              │  ✅ 概率预测器      │        │
│   │  ❌ 完美执行者      │              │  ✅ 信息转换器      │        │
│   └────────────────────┘              └────────────────────┘        │
│                                                                      │
│   所以我们的原则本质是：                                            │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                                                              │   │
│   │   1. 给足信息 ───▶ 因为它不能读心                          │   │
│   │   2. 给好示例 ───▶ 因为它擅长模式匹配                      │   │
│   │   3. 分步引导 ───▶ 因为复杂推理容易出错                    │   │
│   │   4. 明确格式 ───▶ 因为它会"自由发挥"                     │   │
│   │   5. 设置边界 ───▶ 因为它会"胡编乱造"                     │   │
│   │                                                              │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 原则速查表

> 🔥 必须掌握  ⭐ 推荐  💡 进阶

**基础原则（先把这些做对）**

| 优先级 | 原则 | 一句话 | 没做好会怎样 |
|-------|------|--------|------------|
| 🔥 | **角色定义** | 告诉 AI 它是谁 | 输出风格不一致 |
| 🔥 | **上下文充分** | 给足背景信息 | AI 瞎猜，结果离谱 |
| 🔥 | **任务具体** | 清晰、无歧义 | 得到的不是你想要的 |
| 🔥 | **输出格式** | 明确结构要求 | 格式混乱，难以解析 |
| ⭐ | **提供示例** | Few-shot 引导 | 风格不符合预期 |
| ⭐ | **分步指导** | 拆解复杂任务 | 遗漏关键步骤 |
| ⭐ | **思维链** | 展示推理过程 | 复杂问题答错 |
| ⭐ | **约束边界** | 定义"不知道" | 胡编乱造 |

**进阶原则（质量更上一层楼）**

| 优先级 | 原则 | 一句话 | 适用场景 |
|-------|------|--------|---------|
| 💡 | **迭代优化** | 从简单开始 | 复杂任务开发 |
| 💡 | **正向指令** | 说"做"而非"不做" | 所有场景 |
| 💡 | **信息精简** | 只给相关信息 | 长上下文任务 |
| 💡 | **工具定义** | 清晰描述能力边界 | Agent 开发 |
| 💡 | **状态管理** | 管理多轮对话 | 长对话场景 |
| 💡 | **验证机制** | 输出前自查 | 高准确率要求 |

### 场景决策速查

**遇到这些情况，用这些原则：**

```
┌─────────────────────────────────────────────────────────────────────┐
│                    场景 → 原则 映射                                 │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   AI 输出离谱、不是我想要的？                                       │
│   └── 检查：角色定义 + 任务描述 + 上下文                           │
│                                                                      │
│   格式乱七八糟、难以解析？                                          │
│   └── 检查：输出格式 + JSON Schema + 示例                          │
│                                                                      │
│   复杂任务答错、遗漏步骤？                                          │
│   └── 检查：分步指导 + 思维链 + 任务拆解                           │
│                                                                      │
│   AI 胡编乱造、编造事实？                                           │
│   └── 检查：约束边界 + 验证机制 + "不知道就说不知道"               │
│                                                                      │
│   多轮对话越聊越乱？                                                │
│   └── 检查：状态管理 + 上下文压缩 + 记忆机制                       │
│                                                                      │
│   Agent 工具调用出错？                                              │
│   └── 检查：工具定义 + 参数校验 + 错误处理                         │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 好 Prompt vs 坏 Prompt 对比

```
┌─────────────────────────────────────────────────────────────────────┐
│                    直观感受差距                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   ❌ 坏 Prompt：                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  "帮我写个登录功能"                                          │   │
│   │                                                              │   │
│   │  问题：                                                      │   │
│   │  - 什么语言？什么框架？                                      │   │
│   │  - 需要什么认证方式？                                        │   │
│   │  - 有什么安全要求？                                          │   │
│   │  - 要不要记住密码？                                          │   │
│   │  - ...AI 只能瞎猜                                            │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│   ✅ 好 Prompt：                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  ## 角色                                                     │   │
│   │  你是一个 Next.js 15 专家，熟悉 App Router 和 Server Actions │   │
│   │                                                              │   │
│   │  ## 任务                                                     │   │
│   │  实现一个登录表单组件，要求：                                │   │
│   │  1. 使用 Server Action 处理表单提交                          │   │
│   │  2. 支持邮箱 + 密码登录                                      │   │
│   │  3. 使用 Zod 做表单验证                                      │   │
│   │  4. 显示 loading 状态和错误信息                              │   │
│   │                                                              │   │
│   │  ## 约束                                                     │   │
│   │  - 使用 TypeScript，类型要完整                               │   │
│   │  - 不要使用任何 deprecated API                               │   │
│   │  - 遵循 React 19 最佳实践                                    │   │
│   │                                                              │   │
│   │  ## 输出格式                                                 │   │
│   │  分文件输出：LoginForm.tsx, actions.ts, schema.ts            │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
│   差距：从"靠运气"到"可预期"                                       │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 快速检查清单

在提交 Prompt 之前，快速过一遍（3 秒钟）：

```
┌─────────────────────────────────────────────────────────────────────┐
│                    提交前检查                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   □ 角色    →  AI 知道自己是谁吗？                                  │
│   □ 上下文  →  必要的背景信息都给了吗？                             │
│   □ 任务    →  指令清晰、具体、无歧义吗？                           │
│   □ 格式    →  输出格式明确了吗？                                   │
│   □ 边界    →  约束条件和错误处理说明了吗？                         │
│                                                                      │
│   ════════════════════════════════════════════════════════════════  │
│                                                                      │
│   终极测试：                                                         │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                                                              │   │
│   │   "如果我是一个只能看到这些信息的人，                        │   │
│   │    我能合理地完成这个任务吗？"                               │   │
│   │                                                              │   │
│   │    如果答案是"不能"，那 AI 也做不到。                       │   │
│   │                                                              │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 一图总结

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                      │
│                     Prompt Engineering 全景图                        │
│                                                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│   输入层                       处理层                    输出层      │
│   ┌────────┐                 ┌────────┐               ┌────────┐   │
│   │ 角色   │                 │        │               │ 格式   │   │
│   │ 定义   │ ──┐             │        │          ┌──▶ │ 约束   │   │
│   └────────┘   │             │        │          │    └────────┘   │
│   ┌────────┐   │             │        │          │    ┌────────┐   │
│   │ 上下文 │ ──┼──▶  LLM  ───┼────────┼──────────┼──▶ │ 验证   │   │
│   │ 信息   │   │             │        │          │    │ 机制   │   │
│   └────────┘   │             │        │          │    └────────┘   │
│   ┌────────┐   │             │        │          │                  │
│   │ 任务   │ ──┘             │        │          │                  │
│   │ 指令   │                 └────────┘          │                  │
│   └────────┘                      │              │                  │
│   ┌────────┐                      │              │                  │
│   │ 示例   │ ─────────────────────┘              │                  │
│   │ 引导   │                                     │                  │
│   └────────┘                                     │                  │
│   ┌────────┐                                     │                  │
│   │ 约束   │ ────────────────────────────────────┘                  │
│   │ 边界   │                                                        │
│   └────────┘                                                        │
│                                                                      │
│   ═══════════════════════════════════════════════════════════════   │
│                                                                      │
│   核心公式：                                                         │
│   好输出 = 清晰角色 + 充分上下文 + 具体指令 + 示例引导 + 格式约束   │
│                                                                      │
│   不变的原则：                                                       │
│   "给 AI 足够的信息，让它能合理地完成任务"                          │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 八、延伸阅读

- [Prompt Engineering Guide](https://www.promptingguide.ai/) - 最全面的 Prompt 工程指南
- [12 Factor Agents](https://github.com/humanlayer/12-factor-agents) - 构建可靠 LLM 应用的 12 条原则
- [LangChain: The Rise of Context Engineering](https://blog.langchain.com/the-rise-of-context-engineering/) - 上下文工程的兴起
- [Context Engineering Deep Dive](https://www.promptingguide.ai/agents/context-engineering-deep-dive) - 上下文工程深度解析

---

> 💡 **思考题**：当 AI 模型变得越来越强大，你认为 Prompt Engineering 会变得更重要还是更不重要？为什么？

